import type { Block } from 'myst-spec-ext';
import type { FrontmatterParts, GenericParent } from './types.js';
/**
 * Selects the block node(s) based on part (string) or tags (string[]).
 * If `part` is a string array, any of the parts will be treated equally.
 */
export declare function selectBlockParts(tree: GenericParent, part?: string | string[]): Block[];
/**
 * Selects the frontmatterParts entries by `part`
 *
 * If `part` is a string array, any matching part from the frontmatter will be
 * returned.
 *
 * Returns array of blocks.
 */
export declare function selectFrontmatterParts(frontmatterParts?: FrontmatterParts, part?: string | string[]): Block[];
/**
 * Extract implicit part based on heading name
 *
 * Given a tree, search children at the root or block level for a heading
 * with text matching parts. If such heading is encountered, return a copy of
 * the subsequent paragraph nodes until a non-paragraph node is encountered.
 * Heading and paragraph nodes in the original tree are marked for deletion.
 *
 * Ignores anything that is already part of a block with explicit part.
 */
export declare function extractImplicitPart(tree: GenericParent, part?: string | string[], opts?: {
    removePartData?: boolean;
}): GenericParent | undefined;
/**
 * Returns a copy of block parts, if defined in the tree, and removes them from the tree.
 *
 * This does not look at parts defined in frontmatter.
 */
export declare function extractPart(tree: GenericParent, part?: string | string[], opts?: {
    /** Helpful for when we are doing recursions, we don't want to extract the part again. */
    removePartData?: boolean;
    /** Ensure that blocks are by default turned to visible within the part */
    keepVisibility?: boolean;
    /** Provide an option so implicit section-to-part behavior can be disabled */
    requireExplicitPart?: boolean;
    /** Dictionary of part trees, processed from frontmatter */
    frontmatterParts?: FrontmatterParts;
}): GenericParent | undefined;
//# sourceMappingURL=extractParts.d.ts.map