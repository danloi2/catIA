import { remove } from 'unist-util-remove';
import { selectAll } from 'unist-util-select';
import { copyNode, toText } from './utils.js';
import { FRONTMATTER_ALIASES } from 'myst-frontmatter';
function coercePart(part) {
    if (!part) {
        // Prevent an undefined, null or empty part comparison
        return [];
    }
    if (typeof part === 'string')
        return coercePart([part]);
    const parts = [];
    part
        .map((p) => p.toLowerCase())
        .forEach((p) => {
        parts.push(p);
        Object.entries(FRONTMATTER_ALIASES).forEach(([alias, value]) => {
            if (p === alias || p === value) {
                if (!parts.includes(value))
                    parts.unshift(value);
                if (!parts.includes(alias))
                    parts.push(alias);
            }
        });
    });
    return parts;
}
/**
 * Selects the block node(s) based on part (string) or tags (string[]).
 * If `part` is a string array, any of the parts will be treated equally.
 */
export function selectBlockParts(tree, part) {
    const parts = coercePart(part);
    if (parts.length === 0)
        return [];
    const blockParts = selectAll('block', tree).filter((block) => {
        var _a, _b, _c;
        const blockTags = (((_a = block.data) === null || _a === void 0 ? void 0 : _a.tags) && Array.isArray(block.data.tags) ? block.data.tags : []).map((tag) => tag === null || tag === void 0 ? void 0 : tag.toLowerCase());
        const blockPart = (_c = (_b = block.data) === null || _b === void 0 ? void 0 : _b.part) === null || _c === void 0 ? void 0 : _c.toLowerCase();
        return parts
            .map((p) => blockPart === p || blockTags.includes(p))
            .reduce((a, b) => a || b, false);
    });
    return blockParts;
}
/**
 * Selects the frontmatterParts entries by `part`
 *
 * If `part` is a string array, any matching part from the frontmatter will be
 * returned.
 *
 * Returns array of blocks.
 */
export function selectFrontmatterParts(frontmatterParts, part) {
    if (!frontmatterParts)
        return [];
    const parts = coercePart(part);
    if (parts.length === 0)
        return [];
    const blockParts = [];
    parts.forEach((p) => {
        Object.entries(frontmatterParts).forEach(([key, value]) => {
            if (p === key.toLowerCase())
                blockParts.push(...value.mdast.children);
        });
    });
    return blockParts;
}
function createPartBlock(children, part, opts) {
    var _a;
    const block = { type: 'block', children };
    if (!(opts === null || opts === void 0 ? void 0 : opts.removePartData)) {
        (_a = block.data) !== null && _a !== void 0 ? _a : (block.data = {});
        block.data.part = part;
    }
    return block;
}
function forcedRemove(tree, test) {
    let success = remove(tree, test);
    if (!success) {
        success = remove(tree, { cascade: false }, test);
    }
    return success;
}
/**
 * Extract implicit part based on heading name
 *
 * Given a tree, search children at the root or block level for a heading
 * with text matching parts. If such heading is encountered, return a copy of
 * the subsequent paragraph nodes until a non-paragraph node is encountered.
 * Heading and paragraph nodes in the original tree are marked for deletion.
 *
 * Ignores anything that is already part of a block with explicit part.
 */
export function extractImplicitPart(tree, part, opts) {
    var _a;
    const parts = coercePart(part);
    if (parts.length === 0)
        return;
    let insideImplicitPart = false;
    const blockParts = [];
    let paragraphs = [];
    (_a = tree.children) === null || _a === void 0 ? void 0 : _a.forEach((child, index) => {
        var _a;
        // Add this paragraph to the part
        if (insideImplicitPart && child.type === 'paragraph') {
            paragraphs.push(copyNode(child));
            child.type = '__part_delete__';
        }
        // Stop adding things if we didn't just add a paragraph OR we are at the last child
        if (child.type !== '__part_delete__' || index === tree.children.length - 1) {
            insideImplicitPart = false;
            if (paragraphs.length > 0) {
                blockParts.push(createPartBlock(paragraphs, parts[0], opts));
                paragraphs = [];
                selectAll('__part_heading__', tree).forEach((node) => {
                    node.type = '__part_delete__';
                });
            }
        }
        if (child.type === 'block') {
            // Do not search blocks already marked explicitly as parts
            if ((_a = child.data) === null || _a === void 0 ? void 0 : _a.part)
                return;
            // Do not recursively search beyond top-level blocks on root node
            if (tree.type !== 'root')
                return;
            const blockPartsTree = extractImplicitPart(child, parts);
            if (blockPartsTree)
                blockParts.push(...blockPartsTree.children);
        }
        else if (child.type === 'heading' && parts.includes(toText(child).toLowerCase())) {
            // Start adding paragraphs to the part after this heading
            insideImplicitPart = true;
            child.type = '__part_heading__';
        }
    });
    // Restore part headings if they did not contain any paragraphs
    selectAll('__part_heading__', tree).forEach((node) => {
        node.type = 'heading';
    });
    if (blockParts.length === 0)
        return;
    const partsTree = { type: 'root', children: blockParts };
    forcedRemove(tree, '__part_delete__');
    return partsTree;
}
/**
 * Returns a copy of block parts, if defined in the tree, and removes them from the tree.
 *
 * This does not look at parts defined in frontmatter.
 */
export function extractPart(tree, part, opts) {
    const partStrings = coercePart(part);
    if (partStrings.length === 0)
        return;
    const frontmatterParts = selectFrontmatterParts(opts === null || opts === void 0 ? void 0 : opts.frontmatterParts, part);
    const blockParts = selectBlockParts(tree, part);
    if (frontmatterParts.length === 0 && blockParts.length === 0) {
        if (opts === null || opts === void 0 ? void 0 : opts.requireExplicitPart)
            return;
        return extractImplicitPart(tree, partStrings);
    }
    const children = copyNode(frontmatterParts.length > 0 ? frontmatterParts : blockParts).map((block) => {
        var _a;
        // Ensure the block always has the `part` defined, as it might be in the tags
        (_a = block.data) !== null && _a !== void 0 ? _a : (block.data = {});
        block.data.part = partStrings[0];
        if (block.data.tags &&
            Array.isArray(block.data.tags) &&
            block.data.tags.reduce((a, t) => a || partStrings.includes(t.toLowerCase()), false)) {
            block.data.tags = block.data.tags.filter((tag) => !partStrings.includes(tag.toLowerCase()));
            if (block.data.tags.length === 0) {
                delete block.data.tags;
            }
        }
        if (opts === null || opts === void 0 ? void 0 : opts.removePartData)
            delete block.data.part;
        // The default is to remove the visibility on the parts
        if (!(opts === null || opts === void 0 ? void 0 : opts.keepVisibility))
            delete block.visibility;
        return block;
    });
    const partsTree = { type: 'root', children };
    // Remove the block parts from the main document, even if frontmatter parts are returned
    blockParts.forEach((block) => {
        block.type = '__delete__';
    });
    forcedRemove(tree, '__delete__');
    return partsTree;
}
