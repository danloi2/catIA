import { nanoid } from 'nanoid';
import yaml from 'js-yaml';
import { fileError, fileWarn, NotebookCell, RuleId } from 'myst-common';
import { select } from 'unist-util-select';
import { addCommonDirectiveOptions, commonDirectiveOptions } from './utils.js';
function parseEmphasizeLines(emphasizeLinesString) {
    if (!emphasizeLinesString)
        return undefined;
    const emphasizeLines = emphasizeLinesString === null || emphasizeLinesString === void 0 ? void 0 : emphasizeLinesString.split(',').map((val) => Number(val.trim())).filter((val) => Number.isInteger(val));
    return emphasizeLines;
}
/** This function parses both sphinx and RST code-block options */
export function getCodeBlockOptions(data, vfile, defaultFilename) {
    var _a;
    const { options, node } = data;
    if ((options === null || options === void 0 ? void 0 : options['lineno-start']) != null && (options === null || options === void 0 ? void 0 : options['number-lines']) != null) {
        fileWarn(vfile, 'Cannot use both "lineno-start" and "number-lines"', {
            node: (_a = select('mystDirectiveOption[name="number-lines"]', node)) !== null && _a !== void 0 ? _a : node,
            source: 'code-block:options',
            ruleId: RuleId.directiveOptionsCorrect,
        });
    }
    const emphasizeLines = parseEmphasizeLines(options === null || options === void 0 ? void 0 : options['emphasize-lines']);
    const numberLines = options === null || options === void 0 ? void 0 : options['number-lines'];
    // Only include this in mdast if it is `true`
    const showLineNumbers = (options === null || options === void 0 ? void 0 : options.linenos) || (options === null || options === void 0 ? void 0 : options['lineno-start']) || (options === null || options === void 0 ? void 0 : options['lineno-match']) || numberLines
        ? true
        : undefined;
    let startingLineNumber = numberLines != null && numberLines > 1 ? numberLines : options === null || options === void 0 ? void 0 : options['lineno-start'];
    if (options === null || options === void 0 ? void 0 : options['lineno-match']) {
        startingLineNumber = 'match';
    }
    else if (startingLineNumber == null || startingLineNumber <= 1) {
        startingLineNumber = undefined;
    }
    let filename = options === null || options === void 0 ? void 0 : options['filename'];
    if ((filename === null || filename === void 0 ? void 0 : filename.toLowerCase()) === 'false') {
        filename = undefined;
    }
    else if (!filename && defaultFilename) {
        filename = defaultFilename;
    }
    return {
        emphasizeLines,
        showLineNumbers,
        startingLineNumber,
        filename,
    };
}
export const CODE_DIRECTIVE_OPTIONS = {
    caption: {
        type: 'myst',
        doc: 'A parsed caption for the code block.',
    },
    linenos: {
        type: Boolean,
        doc: 'Show line numbers',
    },
    'lineno-start': {
        type: Number,
        doc: 'Start line numbering from a particular value, default is 1. If present, line numbering is activated.',
    },
    'number-lines': {
        type: Number,
        doc: 'Alternative for "lineno-start", turns on line numbering and can be an integer that is the start of the line numbering.',
    },
    'emphasize-lines': {
        type: String,
        doc: 'Emphasize particular lines (comma-separated numbers), e.g. "3,5"',
    },
    filename: {
        type: String,
        doc: 'Show the filename in addition to the rendered code. The `include` directive will use the filename by default, to turn off this default set the filename to `false`.',
    },
    // dedent: {
    //   type: Number,
    //   doc: 'Strip indentation characters from the code block',
    // },
    // force: {
    //   type: Boolean,
    //   doc: 'Ignore minor errors on highlighting',
    // },
};
export function parseTags(input, vfile, node) {
    var _a, _b;
    if (!input)
        return undefined;
    if (typeof input === 'string' && input.startsWith('[') && input.endsWith(']')) {
        try {
            return parseTags(yaml.load(input), vfile, node);
        }
        catch (error) {
            fileError(vfile, 'Could not load tags for code-cell directive', {
                node: (_a = select('mystDirectiveOption[name="tags"]', node)) !== null && _a !== void 0 ? _a : node,
                source: 'code-cell:tags',
                ruleId: RuleId.directiveOptionsCorrect,
            });
            return undefined;
        }
    }
    if (typeof input === 'string') {
        const tags = input
            .split(/[,\s]/)
            .map((t) => t.trim())
            .filter((t) => !!t);
        return tags.length > 0 ? tags : undefined;
    }
    if (!Array.isArray(input))
        return undefined;
    // if the options are loaded directly as yaml (or in recursion)
    const tags = input;
    if (tags && Array.isArray(tags) && tags.every((t) => typeof t === 'string')) {
        if (tags.length > 0) {
            return tags.map((t) => t.trim()).filter((t) => !!t);
        }
    }
    else if (tags) {
        fileWarn(vfile, 'tags in code-cell directive must be a list of strings', {
            node: (_b = select('mystDirectiveOption[name="tags"]', node)) !== null && _b !== void 0 ? _b : node,
            source: 'code-cell:tags',
            ruleId: RuleId.directiveOptionsCorrect,
        });
        return undefined;
    }
}
export const codeDirective = {
    name: 'code',
    doc: 'A code-block environment with a language as the argument, and options for highlighting, showing line numbers, and an optional filename.',
    alias: ['code-block', 'sourcecode'],
    arg: {
        type: String,
        doc: 'Code language, for example `python` or `typescript`',
    },
    options: {
        ...commonDirectiveOptions('code'),
        ...CODE_DIRECTIVE_OPTIONS,
    },
    body: {
        type: String,
        doc: 'The raw code to display for the code block.',
    },
    run(data, vfile) {
        var _a;
        const opts = getCodeBlockOptions(data, vfile);
        const code = {
            type: 'code',
            lang: data.arg,
            ...opts,
            value: data.body,
        };
        if (!((_a = data.options) === null || _a === void 0 ? void 0 : _a.caption)) {
            addCommonDirectiveOptions(data, code);
            return [code];
        }
        const caption = {
            type: 'caption',
            children: [
                {
                    type: 'paragraph',
                    children: data.options.caption,
                },
            ],
        };
        const container = {
            type: 'container',
            kind: 'code',
            children: [code, caption],
        };
        addCommonDirectiveOptions(data, container);
        return [container];
    },
};
export const codeCellDirective = {
    name: 'code-cell',
    doc: 'An executable code cell',
    arg: {
        type: String,
        doc: 'Language for execution and display, for example `python`. It will default to the language of the notebook or containing markdown file.',
    },
    options: {
        ...commonDirectiveOptions('code-cell'),
        caption: {
            type: 'myst',
            doc: 'A parsed caption for the code output.',
        },
        tags: {
            type: String,
            alias: ['tag'],
            doc: 'A comma-separated list of tags to add to the cell, for example, `remove-input` or `hide-cell`.',
        },
    },
    body: {
        type: String,
        doc: 'The code to be executed and displayed.',
    },
    run(data, vfile) {
        var _a, _b, _c;
        const code = {
            type: 'code',
            lang: data.arg,
            executable: true,
            value: ((_a = data.body) !== null && _a !== void 0 ? _a : ''),
        };
        const output = {
            type: 'output',
            id: nanoid(),
            data: [],
        };
        const block = {
            type: 'block',
            kind: NotebookCell.code,
            children: [code, output],
            data: {},
        };
        addCommonDirectiveOptions(data, block);
        if ((_b = data.options) === null || _b === void 0 ? void 0 : _b.caption) {
            // This is changed into a figure/container with a caption in `blockToFigureTransform`
            // This can also be added using the `#| caption:` metadata in the code directly
            block.data.caption = [{ type: 'paragraph', children: data.options.caption }];
        }
        const tags = parseTags((_c = data.options) === null || _c === void 0 ? void 0 : _c.tags, vfile, data.node);
        if (tags)
            block.data.tags = tags;
        return [block];
    },
};
