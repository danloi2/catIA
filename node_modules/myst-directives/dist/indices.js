import { createIndexEntries, fileError, parseIndexLine } from 'myst-common';
function warnOnOptionSyntax(option, value, vfile, node) {
    fileError(vfile, `Index entry definitions should not use :option: syntax`, {
        node,
        note: `Replace ":${option}: ${value}" with "${option}: ${value}"`,
    });
}
export const indexDirective = {
    name: 'index',
    arg: {
        type: String,
    },
    options: {
        single: {
            type: String,
        },
        pair: {
            type: String,
        },
        triple: {
            type: String,
        },
        see: {
            type: String,
        },
        seealso: {
            type: String,
            alias: ['seeAlso', 'see-also'],
        },
        label: {
            type: String,
            alias: ['name'],
        },
    },
    body: {
        type: String,
    },
    run(data, vfile) {
        var _a, _b, _c, _d, _e, _f;
        const values = { single: [], pair: [], triple: [], see: [], seealso: [] };
        if (data.arg)
            parseIndexLine(data.arg, values, vfile, data.node);
        if ((_a = data.options) === null || _a === void 0 ? void 0 : _a.single) {
            warnOnOptionSyntax('single', data.options.single, vfile, data.node);
            values.single.push(data.options.single);
        }
        if ((_b = data.options) === null || _b === void 0 ? void 0 : _b.pair) {
            warnOnOptionSyntax('pair', data.options.pair, vfile, data.node);
            values.pair.push(data.options.pair);
        }
        if ((_c = data.options) === null || _c === void 0 ? void 0 : _c.triple) {
            warnOnOptionSyntax('triple', data.options.triple, vfile, data.node);
            values.triple.push(data.options.triple);
        }
        if ((_d = data.options) === null || _d === void 0 ? void 0 : _d.see) {
            warnOnOptionSyntax('see', data.options.see, vfile, data.node);
            values.see.push(data.options.see);
        }
        if ((_e = data.options) === null || _e === void 0 ? void 0 : _e.seealso) {
            warnOnOptionSyntax('seealso', data.options.seealso, vfile, data.node);
            values.seealso.push(data.options.seealso);
        }
        if (data.body) {
            data.body.split('\n').forEach((line) => {
                parseIndexLine(line, values, vfile, data.node);
            });
        }
        const entries = createIndexEntries(values, vfile, data.node);
        const output = [
            {
                type: 'mystTarget',
                label: (_f = data.options) === null || _f === void 0 ? void 0 : _f.label,
                indexEntries: entries,
            },
        ];
        return output;
    },
};
export const genIndexDirective = {
    name: 'show-index',
    alias: ['genindex'],
    arg: {
        type: 'myst',
        doc: 'Heading to be included in index block',
    },
    run(data) {
        var _a;
        const children = [];
        if (data.arg) {
            const parsedArg = data.arg;
            if (((_a = parsedArg[0]) === null || _a === void 0 ? void 0 : _a.type) === 'heading') {
                children.push(...parsedArg);
            }
            else {
                children.push({
                    type: 'heading',
                    depth: 2,
                    enumerated: false,
                    children: parsedArg,
                });
            }
        }
        return [{ type: 'genindex', children }];
    },
};
