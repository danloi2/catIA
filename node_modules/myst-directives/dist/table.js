import { fileError, RuleId } from 'myst-common';
import { parse } from 'csv-parse/browser/esm/sync';
import { select } from 'unist-util-select';
import { addCommonDirectiveOptions, commonDirectiveOptions } from './utils.js';
export const tableDirective = {
    name: 'table',
    arg: {
        type: 'myst',
        doc: 'An optional table caption',
    },
    options: {
        ...commonDirectiveOptions('table'),
        class: {
            type: String,
            // class_option: list of strings?
            doc: `CSS classes to add to your table. Special classes include:

- \`full-width\`: changes the table environment to cover two columns in LaTeX`,
        },
        align: {
            type: String,
            // choice(['left', 'center', 'right'])
        },
    },
    body: {
        type: 'myst',
        required: true,
    },
    run(data) {
        const children = [];
        if (data.arg) {
            children.push({
                type: 'caption',
                children: [{ type: 'paragraph', children: data.arg }],
            });
        }
        children.push(...data.body);
        const container = {
            type: 'container',
            kind: 'table',
            children,
        };
        addCommonDirectiveOptions(data, container);
        return [container];
    },
};
export const listTableDirective = {
    name: 'list-table',
    arg: {
        type: 'myst',
        doc: 'An optional table caption',
    },
    options: {
        ...commonDirectiveOptions('list table'),
        'header-rows': {
            type: Number,
            // nonnegative int
        },
        // 'stub-columns': {
        //   type: Number,
        //   // nonnegative int
        // },
        // width: {
        //   type: String,
        //   // length_or_percentage_or_unitless,
        // },
        // widths: {
        //   type: String,
        //   // TODO use correct widths option validator
        // },
        class: {
            type: String,
            // class_option: list of strings?
            doc: `CSS classes to add to your table. Special classes include:

- \`full-width\`: changes the table environment to cover two columns in LaTeX`,
        },
        align: {
            type: String,
            // choice(['left', 'center', 'right'])
        },
    },
    body: {
        type: 'myst',
        required: true,
    },
    validate(data, vfile) {
        var _a;
        const validatedData = { ...data };
        const parsedBody = data.body;
        if (parsedBody.length !== 1 || parsedBody[0].type !== 'list') {
            fileError(vfile, 'list-table directive must have one list as body', {
                node: data.node,
                ruleId: RuleId.directiveBodyCorrect,
            });
            validatedData.body = [];
        }
        else {
            (_a = parsedBody[0].children) === null || _a === void 0 ? void 0 : _a.forEach((listItem) => {
                var _a, _b;
                if (!validatedData.body.length)
                    return;
                if (listItem.type !== 'listItem' ||
                    ((_a = listItem.children) === null || _a === void 0 ? void 0 : _a.length) !== 1 ||
                    ((_b = listItem.children[0]) === null || _b === void 0 ? void 0 : _b.type) !== 'list') {
                    fileError(vfile, 'list-table directive must have a list of lists', {
                        node: data.node,
                        ruleId: RuleId.directiveBodyCorrect,
                    });
                    validatedData.body = [];
                }
            });
        }
        return validatedData;
    },
    run(data) {
        var _a, _b, _c;
        const children = [];
        if (data.arg) {
            children.push({
                type: 'caption',
                children: [{ type: 'paragraph', children: data.arg }],
            });
        }
        const topListChildren = ((_a = data.body[0]) === null || _a === void 0 ? void 0 : _a.children) || [];
        let headerCount = ((_b = data.options) === null || _b === void 0 ? void 0 : _b['header-rows']) || 0;
        const table = {
            type: 'table',
            align: (_c = data.options) === null || _c === void 0 ? void 0 : _c.align,
            children: topListChildren.map((topListItem) => {
                var _a, _b;
                const nestedListChildren = ((_b = (_a = topListItem.children) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.children) || [];
                const row = {
                    type: 'tableRow',
                    children: nestedListChildren.map((nestedListItem) => {
                        const cell = {
                            type: 'tableCell',
                            header: headerCount > 0 ? true : undefined,
                            children: nestedListItem.children,
                        };
                        return cell;
                    }),
                };
                headerCount -= 1;
                return row;
            }),
        };
        children.push(table);
        const container = {
            type: 'container',
            kind: 'table',
            children,
        };
        addCommonDirectiveOptions(data, container);
        return [container];
    },
};
/**
 * Parse a CSV-table comprising of (inline) MyST Markdown
 *
 * @param data - CSV string
 * @param opts - directive options
 * @param ctx - directive evaluation context
 */
function parseCSV(data, ctx, opts) {
    var _a, _b, _c;
    const delimiter = (_a = opts === null || opts === void 0 ? void 0 : opts.delim) !== null && _a !== void 0 ? _a : ',';
    const records = parse(data, {
        delimiter: delimiter === 'tab' ? '\t' : delimiter === 'space' ? ' ' : delimiter,
        ltrim: !(opts === null || opts === void 0 ? void 0 : opts.keepspace),
        escape: (_b = opts === null || opts === void 0 ? void 0 : opts.escape) !== null && _b !== void 0 ? _b : '"',
        quote: (_c = opts === null || opts === void 0 ? void 0 : opts.quote) !== null && _c !== void 0 ? _c : '"',
    });
    return records.map((record, recordIndex) => {
        return record.map((cell) => {
            const mdast = ctx.parseMyst(cell, recordIndex);
            // May be null!
            return select('*:root > paragraph:only-child', mdast);
        });
    });
}
// Documentation is from Docutils
// License is public domain: https://docutils.sourceforge.io/COPYING.html
export const csvTableDirective = {
    name: 'csv-table',
    doc: 'The "csv-table" directive is used to create a table from CSV (comma-separated values) data.',
    arg: {
        type: 'myst',
        doc: 'An optional table caption',
    },
    options: {
        ...commonDirectiveOptions('CSV table'),
        // file: {
        //   type: String,
        //   doc: 'The local filesystem path to a CSV data file.',
        //   alias: ['url'],
        //  Add this to the description for the directive:
        //  The data may be internal (an integral part of the document) or external (a separate file).
        // },
        header: {
            type: String,
            // nonnegative int
            doc: 'Supplemental data for the table header, added independently of and before any header-rows from the main CSV data. Must use the same CSV format as the main CSV data.',
        },
        'header-rows': {
            type: Number,
            // nonnegative int
            doc: 'The number of rows of CSV data to use in the table header. Defaults to 0.',
        },
        class: {
            type: String,
            // class_option: list of strings?
            doc: `CSS classes to add to your table. Special classes include:

- \`full-width\`: changes the table environment to cover two columns in LaTeX`,
        },
        align: {
            type: String,
            // choice(['left', 'center', 'right'])
        },
        delim: {
            type: String,
            doc: 'The character used to separate data fields. The special values "tab" and "space" are converted to the respective whitespace characters. Defaults to "," (comma)',
        },
        keepspace: {
            type: Boolean,
            doc: 'Treat whitespace immediately following the delimiter as significant. The default is to ignore such whitespace.',
        },
        quote: {
            type: String,
            doc: 'The character used to quote fields containing special characters, such as the delimiter, quotes, or new-line characters. Must be a single character, defaults to `"` (a double quote)\\\nFor example, `First cell, "These commas, for example, are escaped", Next cell`',
        },
        escape: {
            type: String,
            doc: 'A character used to escape the delimiter or quote characters from the CSV parser. Must be a single character, defaults to `"` (a double quote) default is a double quote\\\nFor example, `First cell, "These quotes"", for example, are escaped", Next cell`',
        },
    },
    body: {
        type: String,
        doc: 'The CSV content',
        required: true,
    },
    run(data, vfile, ctx) {
        var _a, _b, _c, _d, _e;
        const captions = [];
        if (data.arg) {
            captions.push({
                type: 'caption',
                children: [{ type: 'paragraph', children: data.arg }],
            });
        }
        const rows = [];
        if (((_a = data.options) === null || _a === void 0 ? void 0 : _a.header) !== undefined) {
            let headerCells = [];
            try {
                headerCells = parseCSV(data.options.header, ctx, data.options);
            }
            catch (error) {
                fileError(vfile, 'csv-table directive header must be valid CSV-formatted MyST', {
                    node: (_b = select('mystDirectiveOption[name="header"]', data.node)) !== null && _b !== void 0 ? _b : data.node,
                    ruleId: RuleId.directiveOptionsCorrect,
                });
            }
            rows.push(...headerCells.map((parsedRow) => ({
                type: 'tableRow',
                children: parsedRow.map((parsedCell) => {
                    var _a;
                    return ({
                        type: 'tableCell',
                        header: true,
                        children: (_a = parsedCell === null || parsedCell === void 0 ? void 0 : parsedCell.children) !== null && _a !== void 0 ? _a : [],
                    });
                }),
            })));
        }
        let bodyCells = [];
        try {
            bodyCells = parseCSV(data.body, ctx, data.options);
        }
        catch (error) {
            fileError(vfile, 'csv-table directive body must be valid CSV-formatted MyST', {
                node: (_c = select('mystDirectiveBody', data.node)) !== null && _c !== void 0 ? _c : data.node,
                ruleId: RuleId.directiveBodyCorrect,
            });
        }
        let headerCount = ((_d = data.options) === null || _d === void 0 ? void 0 : _d['header-rows']) || 0;
        rows.push(...bodyCells.map((parsedRow) => {
            const row = {
                type: 'tableRow',
                children: parsedRow.map((parsedCell) => {
                    var _a;
                    return ({
                        type: 'tableCell',
                        header: headerCount > 0 ? true : undefined,
                        children: (_a = parsedCell === null || parsedCell === void 0 ? void 0 : parsedCell.children) !== null && _a !== void 0 ? _a : [],
                    });
                }),
            };
            headerCount -= 1;
            return row;
        }));
        const table = {
            type: 'table',
            align: (_e = data.options) === null || _e === void 0 ? void 0 : _e.align,
            children: rows,
        };
        const container = {
            type: 'container',
            kind: 'table',
            children: [...captions, table],
        };
        addCommonDirectiveOptions(data, container);
        return [container];
    },
};
