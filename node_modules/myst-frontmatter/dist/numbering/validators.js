import { defined, fillMissingKeys, incrementOptions, validateBoolean, validateNumber, validateObjectKeys, validateString, validationWarning, } from 'simple-validators';
export const NUMBERING_OPTIONS = ['enumerator', 'all', 'headings', 'title'];
const HEADING_KEYS = ['heading_1', 'heading_2', 'heading_3', 'heading_4', 'heading_5', 'heading_6'];
export const NUMBERING_KEYS = [
    'figure',
    'subfigure',
    'equation',
    'subequation',
    'table',
    'code',
    ...HEADING_KEYS,
];
const NUMBERING_ITEM_KEYS = ['enabled', 'start', 'enumerator', 'template', 'continue'];
const CONTINUE_STRINGS = ['continue', 'next'];
export const NUMBERING_ALIAS = {
    sections: 'headings',
    h1: 'heading_1',
    h2: 'heading_2',
    h3: 'heading_3',
    h4: 'heading_4',
    h5: 'heading_5',
    h6: 'heading_6',
    heading1: 'heading_1',
    heading2: 'heading_2',
    heading3: 'heading_3',
    heading4: 'heading_4',
    heading5: 'heading_5',
    heading6: 'heading_6',
    figures: 'figure',
    subfigures: 'subfigure',
    equations: 'equation',
    subequations: 'subequation',
    tables: 'table',
    titles: 'title',
};
function isBoolean(input) {
    if (typeof input === 'string') {
        return ['true', 'false'].includes(input.toLowerCase());
    }
    return typeof input === 'boolean';
}
/**
 * Validate value for each numbering entry
 *
 * Value may be:
 * - boolean, to simply enable/disable numbering
 * - number, to indicate the starting number
 * - string, to define the cross-reference template
 *   (e.g. 'Fig. %s' to get "Fig. 1" instead of "Figure 1" in your document)
 * - An object with any of enabled/start/template - specifying the above types
 *   will coerce to this object
 */
export function validateNumberingItem(input, opts) {
    var _a, _b, _c, _d, _e;
    if (isBoolean(input)) {
        input = { enabled: input };
    }
    else if (typeof input === 'number') {
        input = { start: input };
    }
    else if (CONTINUE_STRINGS.includes(input)) {
        input = { continue: true };
    }
    else if (typeof input === 'string') {
        input = { template: input };
    }
    const value = validateObjectKeys(input, { optional: NUMBERING_ITEM_KEYS }, opts);
    if (value === undefined)
        return undefined;
    const output = {};
    if (defined(value.enabled)) {
        const enabled = validateBoolean(value.enabled, incrementOptions('enabled', opts));
        if (defined(enabled))
            output.enabled = enabled;
    }
    if (defined(value.start)) {
        if (CONTINUE_STRINGS.includes(value.start) && !defined(value.continue)) {
            output.continue = true;
            output.enabled = (_a = output.enabled) !== null && _a !== void 0 ? _a : true;
        }
        else {
            const start = validateNumber(value.start, {
                ...incrementOptions('start', opts),
                integer: true,
                min: 1,
            });
            if (start) {
                output.start = start;
                output.enabled = (_b = output.enabled) !== null && _b !== void 0 ? _b : true;
            }
        }
    }
    if (defined(value.template)) {
        const template = validateString(value.template, incrementOptions('template', opts));
        if (defined(template)) {
            output.template = template;
            output.enabled = (_c = output.enabled) !== null && _c !== void 0 ? _c : true;
        }
    }
    if (defined(value.enumerator)) {
        const enumerator = validateString(value.enumerator, incrementOptions('enumerator', opts));
        if (defined(enumerator)) {
            output.enumerator = enumerator;
            output.enabled = (_d = output.enabled) !== null && _d !== void 0 ? _d : true;
        }
    }
    if (defined(value.continue)) {
        const cont = validateBoolean(value.continue, incrementOptions('continue', opts));
        if (defined(cont)) {
            output.continue = cont;
            output.enabled = (_e = output.enabled) !== null && _e !== void 0 ? _e : true;
        }
    }
    if (Object.keys(output).length === 0)
        return undefined;
    return output;
}
export function validateTitleItem(input, opts) {
    var _a, _b;
    if (isBoolean(input)) {
        input = { enabled: input };
    }
    else if (typeof input === 'number') {
        input = { offset: input };
    }
    const value = validateObjectKeys(input, { optional: ['enabled', 'offset', 'enumerator'] }, opts);
    if (value === undefined)
        return undefined;
    const output = {};
    if (defined(value.enabled)) {
        const enabled = validateBoolean(value.enabled, incrementOptions('enabled', opts));
        if (defined(enabled))
            output.enabled = enabled;
    }
    if (defined(value.offset)) {
        const offset = validateNumber(value.offset, {
            integer: true,
            min: 0,
            max: 5,
            ...incrementOptions('offset', opts),
        });
        if (defined(offset)) {
            output.offset = offset;
            output.enabled = (_a = output.enabled) !== null && _a !== void 0 ? _a : true;
        }
    }
    if (defined(value.enumerator)) {
        const enumerator = validateString(value.enumerator, incrementOptions('enumerator', opts));
        if (defined(enumerator)) {
            output.enumerator = enumerator;
            output.enabled = (_b = output.enabled) !== null && _b !== void 0 ? _b : true;
        }
    }
    if (Object.keys(output).length === 0)
        return undefined;
    return output;
}
/**
 * Validate Numbering object
 */
export function validateNumbering(input, opts) {
    var _a, _b, _c, _d, _e;
    if (isBoolean(input)) {
        input = { all: input };
    }
    const value = validateObjectKeys(input, { optional: [...NUMBERING_KEYS, ...NUMBERING_OPTIONS], alias: NUMBERING_ALIAS }, { ...opts, suppressWarnings: true, keepExtraKeys: true });
    if (value === undefined)
        return undefined;
    const output = {};
    let headings;
    if (defined(value.enumerator)) {
        const enumeratorOpts = incrementOptions('enumerator', opts);
        if (typeof value.enumerator === 'string') {
            value.enumerator = { enumerator: value.enumerator };
        }
        output.enumerator = validateNumberingItem(value.enumerator, enumeratorOpts);
        if (((_a = output.enumerator) === null || _a === void 0 ? void 0 : _a.enabled) != null) {
            if (output.enumerator.enabled !== true) {
                validationWarning("value for 'enabled' is ignored", enumeratorOpts);
            }
            delete output.enumerator.enabled;
        }
        if (((_b = output.enumerator) === null || _b === void 0 ? void 0 : _b.start) != null) {
            validationWarning("value for 'start' is ignored", enumeratorOpts);
            delete output.enumerator.start;
        }
        if (((_c = output.enumerator) === null || _c === void 0 ? void 0 : _c.continue) != null) {
            validationWarning("value for 'continue' is ignored", enumeratorOpts);
            delete output.enumerator.continue;
        }
        if (!output.enumerator || Object.keys(output.enumerator).length === 0) {
            delete output.enumerator;
        }
    }
    if (defined(value.all)) {
        const allOpts = incrementOptions('all', opts);
        output.all = validateNumberingItem(value.all, allOpts);
        if (((_d = output.all) === null || _d === void 0 ? void 0 : _d.template) != null) {
            validationWarning("value for 'template' is ignored", allOpts);
            delete output.all.template;
        }
        if (((_e = output.all) === null || _e === void 0 ? void 0 : _e.start) != null) {
            validationWarning("value for 'start' is ignored", allOpts);
            delete output.all.start;
        }
        if (!output.all || Object.keys(output.all).length === 0) {
            delete output.all;
        }
    }
    if (defined(value.title)) {
        output.title = validateTitleItem(value.title, incrementOptions('title', opts));
    }
    if (defined(value.headings)) {
        headings = validateNumberingItem(value.headings, incrementOptions('headings', opts));
        HEADING_KEYS.forEach((headingKey) => {
            if (headings && !defined(value[headingKey])) {
                value[headingKey] = headings;
            }
        });
    }
    Object.keys(value)
        .filter((key) => !NUMBERING_OPTIONS.includes(key)) // For all the unknown options
        .forEach((key) => {
        if (defined(value[key])) {
            const item = validateNumberingItem(value[key], incrementOptions(key, opts));
            if (!defined(item))
                return;
            if (headings && HEADING_KEYS.includes(key)) {
                output[key] = { ...headings, ...item };
            }
            else {
                output[key] = item;
            }
        }
    });
    if (Object.keys(output).length === 0)
        return undefined;
    return output;
}
export function fillNumbering(base, filler) {
    const output = { ...filler, ...base };
    Object.entries(filler !== null && filler !== void 0 ? filler : {})
        .filter(([key]) => !NUMBERING_OPTIONS.includes(key))
        .forEach(([key, val]) => {
        var _a, _b, _c, _d, _e;
        output[key] = fillMissingKeys((_a = base === null || base === void 0 ? void 0 : base[key]) !== null && _a !== void 0 ? _a : {}, 
        // Enabling/disabling all in base overrides filler
        {
            ...val,
            enabled: (_c = (_b = base === null || base === void 0 ? void 0 : base.all) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : val.enabled,
            continue: (_e = (_d = base === null || base === void 0 ? void 0 : base.all) === null || _d === void 0 ? void 0 : _d.continue) !== null && _e !== void 0 ? _e : val.continue,
        }, NUMBERING_ITEM_KEYS);
    });
    return output;
}
